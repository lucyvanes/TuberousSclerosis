}
# don't sit reds next to whites
#================================
reds <- which(pool=="B1_r" | pool=="B2_r" | pool=="T1_r" | pool=="T2_r" | pool=="A1_r" | pool=="A2_r" | pool=="S1_r" | pool=="S2_r")
yellows <- which(pool=="B1_y" | pool=="B2_y" | pool=="T1_y" | pool=="T2_y" | pool=="A1_y" | pool=="A2_y" | pool=="S1_y" | pool=="S2_y")
whites <- which(pool=="B1_w" | pool=="B2_w" | pool=="T1_w" | pool=="T2_w" | pool=="A1_w" | pool=="A2_w" | pool=="S1_w" | pool=="S2_w")
if (dat$colour[l-1]=="w"){
pool <- pool[c(whites, yellows)]
}
if (dat$colour[l-1]=="r"){
pool <- pool[c(yellows, reds)]
}
#========================================================
label <- sample(pool, 1)
print(label)
dat$label[l] <- label
dat$voice[l] <- substr(label, 1, 1)
dat$height[l] <- substr(label, 2, 2)
dat$colour[l] <- substr(label, 4, 4)
indx <- which(choir==label)[1]
choir <- choir[-indx]
}
}
dat$label
matrix(dat$label)
?matrix
matrix(dat$label, nrow=rows)
rows
matrix(dat$label, nrow=n_rows)
matrix(dat$label, nrow=n_rows, byrow=T)
dat <- data.frame(row = rep(1:n_rows, each=seats_per_row), seat = rep(1:seats_per_row, n_rows), edge=0, order=NA, label = NA, voice = NA, height= NA, colour = NA)
for (t in 1:length(dat$order)){
if(t==1){
n <- 1
}
dat$order[t] <- n
}
t
t==1
dat <- data.frame(row = rep(1:n_rows, each=seats_per_row), seat = rep(1:seats_per_row, n_rows), edge=0, order=NA, label = NA, voice = NA, height= NA, colour = NA)
dat$order[1] <- 1
2:length(dat$order)
t
t <- 2
dat$order[t] <- n + n_rows*1
n_rows
seats_per_row
29/2
dat$row[t]
dat$seat[t]
dat$row[t]==1 & dat$seat[t] < seats_per_row/2
if (dat$row[t]==1 & dat$seat[t] < seats_per_row/2){
dat$order[t] <- n + n_rows*1
}
dat <- data.frame(row = rep(1:n_rows, each=seats_per_row), seat = rep(1:seats_per_row, n_rows), edge=0, order=NA, label = NA, voice = NA, height= NA, colour = NA)
dat$edge[dat$seat==1 | dat$seat==seats_per_row] <- 1
dat$order[1] <- 1
for (t in 2:length(dat$order)){
if (dat$row[t]==1 & dat$seat[t] < seats_per_row/2){
dat$order[t] <- n + n_rows*1
}
}
dat$order[1] <- 1
for (t in 2:length(dat$order)){
if (dat$row[t]==1 & dat$seat[t] < seats_per_row/2){
n <- n + n_rows*1
dat$order[t] <- n
}
}
B1_r <- 10
B1_y <- 5
B1_w <- 3
B2_r <- 11
B2_y <- 4
B2_w <- 5
T1_r <- 7
T1_y <- 9
T1_w <- 2
T2_r <- 8
T2_y <- 7
T2_w <- 3
A1_r <- 8
A1_y <- 5
A1_w <- 4
A2_r <- 7
A2_y <- 12
A2_w <- 3
S1_r <- 10
S1_y <- 5
S1_w <- 3
S2_r <- 8
S2_y <- 7
S2_w <- 4
choir <- c(rep("B1_r",B1_r), rep("B1_y", B1_y), rep(rep("B1_w", B1_w)),
rep("B2_r",B2_r), rep("B2_y", B2_y), rep(rep("B2_w", B2_w)),
rep("T1_r",T1_r), rep("T1_y", T1_y), rep(rep("T1_w", T1_w)),
rep("T2_r",T2_r), rep("T2_y", T2_y), rep(rep("T2_w", T2_w)),
rep("A1_r",A1_r), rep("A1_y", A1_y), rep(rep("A1_w", A1_w)),
rep("A2_r",A2_r), rep("A2_y", A2_y), rep(rep("A2_w", A2_w)),
rep("S1_r",S1_r), rep("S1_y", S1_y), rep(rep("S1_w", S1_w)),
rep("S2_r",S2_r), rep("S2_y", S2_y), rep(rep("S2_w", S2_w)))
# n_singers <- B1_r + B1_y + B1_w + B2_r + B2_y + B2_w +
#  T1_r + T1_y + T1_w + T2_r + T2_y + T2_w +
#  A1_r + A1_y + A1_w + A2_r + A2_y + A2_w +
#  S1_r + S1_y + S1_w + S2_r + S2_y + S2_w
n_singers <- length(choir)
n_singers
n_rows <- 5
seats_per_row <- n_singers / n_rows
#==============================================================================
dat <- data.frame(row = rep(1:n_rows, each=seats_per_row), seat = rep(1:seats_per_row, n_rows), edge=0, order=NA, label = NA, voice = NA, height= NA, colour = NA)
dat$edge[dat$seat==1 | dat$seat==seats_per_row] <- 1
# Fill in edges first
#=======================
edges <- which(dat$edge==1)
for (l in edges){
pool <- choir
whites <- which(pool=="B1_w" | pool=="B2_w" | pool=="T1_w" | pool=="T2_w" | pool=="A1_w" | pool=="A2_w" | pool=="A1_w" | pool=="A2_w")
pool <- pool[whites]
label <- sample(pool, 1)
dat$label[l] <- label
dat$voice[l] <- substr(label, 1, 1)
dat$height[l] <- substr(label, 2, 2)
dat$colour[l] <- substr(label, 4, 4)
indx <- which(choir==label)[1]
choir <- choir[-indx]
}
# # Define seating order
# #=========================
#
# dat$order[1] <- 1
#
# for (t in 2:length(dat$order)){
#
#   if (dat$row[t]==1 & dat$seat[t] < seats_per_row/2){
#     n <- n + n_rows*1
#     dat$order[t] <- n
#   }
# }
#
# Fill in rest
#===========================
for (l in 1:length(dat$label)){
print(paste("ROW", dat$row[l], "SEAT", dat$seat[l], sep=" "))
if (!is.na(dat$label[l])){
print("Edge seat- already labelled")
} else {
pool <- choir
basses <- which(pool=="B1_r" | pool=="B1_y" | pool=="B1_w" | pool=="B2_r" | pool=="B2_y" | pool=="B2_w")
tenors <- which(pool=="T1_r" | pool=="T1_y" | pool=="T1_w" | pool=="T2_r" | pool=="T2_y" | pool=="T2_w")
altos <- which(pool=="A1_r" | pool=="A1_y" | pool=="A1_w" | pool=="A2_r" | pool=="A2_y" | pool=="A2_w")
sopranos <- which(pool=="S1_r" | pool=="S1_y" | pool=="S1_w" | pool=="S2_r" | pool=="S2_y" | pool=="S2_w")
# don't seat same voice parts next to each other
#=================================================
# BASS
if (dat$voice[l-1]=="B"){
pool <- pool[c(tenors, altos, sopranos)]
}
# TENORS
if (dat$voice[l-1]=="T"){
pool <- pool[c(basses, altos, sopranos)]
}
# ALTOS
if (dat$voice[l-1]=="A"){
pool <- pool[c(basses, tenors, sopranos)]
}
# SOPRANOS
if (dat$voice[l-1]=="S"){
pool <- pool[c(basses, tenors, altos)]
}
# don't sit reds next to whites
#================================
reds <- which(pool=="B1_r" | pool=="B2_r" | pool=="T1_r" | pool=="T2_r" | pool=="A1_r" | pool=="A2_r" | pool=="S1_r" | pool=="S2_r")
yellows <- which(pool=="B1_y" | pool=="B2_y" | pool=="T1_y" | pool=="T2_y" | pool=="A1_y" | pool=="A2_y" | pool=="S1_y" | pool=="S2_y")
whites <- which(pool=="B1_w" | pool=="B2_w" | pool=="T1_w" | pool=="T2_w" | pool=="A1_w" | pool=="A2_w" | pool=="S1_w" | pool=="S2_w")
if (dat$colour[l-1]=="w"){
pool <- pool[c(whites, yellows)]
}
if (dat$colour[l-1]=="r"){
pool <- pool[c(yellows, reds)]
}
#========================================================
label <- sample(pool, 1)
print(label)
dat$label[l] <- label
dat$voice[l] <- substr(label, 1, 1)
dat$height[l] <- substr(label, 2, 2)
dat$colour[l] <- substr(label, 4, 4)
indx <- which(choir==label)[1]
choir <- choir[-indx]
}
}
#===========================================================
jumbled <- matrix(dat$label, nrow=n_rows, byrow=T)
pool
length(pool)
#========================================================
if (length(pool)==0){
pool <- choir
}
label <- sample(pool, 1)
B1_r <- 10
B1_y <- 5
B1_w <- 3
B2_r <- 11
B2_y <- 4
B2_w <- 5
T1_r <- 7
T1_y <- 9
T1_w <- 2
T2_r <- 8
T2_y <- 7
T2_w <- 3
A1_r <- 8
A1_y <- 5
A1_w <- 4
A2_r <- 7
A2_y <- 12
A2_w <- 3
S1_r <- 10
S1_y <- 5
S1_w <- 3
S2_r <- 8
S2_y <- 7
S2_w <- 4
choir <- c(rep("B1_r",B1_r), rep("B1_y", B1_y), rep(rep("B1_w", B1_w)),
rep("B2_r",B2_r), rep("B2_y", B2_y), rep(rep("B2_w", B2_w)),
rep("T1_r",T1_r), rep("T1_y", T1_y), rep(rep("T1_w", T1_w)),
rep("T2_r",T2_r), rep("T2_y", T2_y), rep(rep("T2_w", T2_w)),
rep("A1_r",A1_r), rep("A1_y", A1_y), rep(rep("A1_w", A1_w)),
rep("A2_r",A2_r), rep("A2_y", A2_y), rep(rep("A2_w", A2_w)),
rep("S1_r",S1_r), rep("S1_y", S1_y), rep(rep("S1_w", S1_w)),
rep("S2_r",S2_r), rep("S2_y", S2_y), rep(rep("S2_w", S2_w)))
# n_singers <- B1_r + B1_y + B1_w + B2_r + B2_y + B2_w +
#  T1_r + T1_y + T1_w + T2_r + T2_y + T2_w +
#  A1_r + A1_y + A1_w + A2_r + A2_y + A2_w +
#  S1_r + S1_y + S1_w + S2_r + S2_y + S2_w
n_singers <- length(choir)
n_singers
n_rows <- 5
seats_per_row <- n_singers / n_rows
#==============================================================================
dat <- data.frame(row = rep(1:n_rows, each=seats_per_row), seat = rep(1:seats_per_row, n_rows), edge=0, order=NA, label = NA, voice = NA, height= NA, colour = NA)
dat$edge[dat$seat==1 | dat$seat==seats_per_row] <- 1
# Fill in edges first
#=======================
edges <- which(dat$edge==1)
for (l in edges){
pool <- choir
whites <- which(pool=="B1_w" | pool=="B2_w" | pool=="T1_w" | pool=="T2_w" | pool=="A1_w" | pool=="A2_w" | pool=="A1_w" | pool=="A2_w")
pool <- pool[whites]
label <- sample(pool, 1)
dat$label[l] <- label
dat$voice[l] <- substr(label, 1, 1)
dat$height[l] <- substr(label, 2, 2)
dat$colour[l] <- substr(label, 4, 4)
indx <- which(choir==label)[1]
choir <- choir[-indx]
}
# # Define seating order
# #=========================
#
# dat$order[1] <- 1
#
# for (t in 2:length(dat$order)){
#
#   if (dat$row[t]==1 & dat$seat[t] < seats_per_row/2){
#     n <- n + n_rows*1
#     dat$order[t] <- n
#   }
# }
#
# Fill in rest
#===========================
for (l in 1:length(dat$label)){
print(paste("ROW", dat$row[l], "SEAT", dat$seat[l], sep=" "))
if (!is.na(dat$label[l])){
print("Edge seat- already labelled")
} else {
pool <- choir
basses <- which(pool=="B1_r" | pool=="B1_y" | pool=="B1_w" | pool=="B2_r" | pool=="B2_y" | pool=="B2_w")
tenors <- which(pool=="T1_r" | pool=="T1_y" | pool=="T1_w" | pool=="T2_r" | pool=="T2_y" | pool=="T2_w")
altos <- which(pool=="A1_r" | pool=="A1_y" | pool=="A1_w" | pool=="A2_r" | pool=="A2_y" | pool=="A2_w")
sopranos <- which(pool=="S1_r" | pool=="S1_y" | pool=="S1_w" | pool=="S2_r" | pool=="S2_y" | pool=="S2_w")
# don't seat same voice parts next to each other
#=================================================
# BASS
if (dat$voice[l-1]=="B"){
pool <- pool[c(tenors, altos, sopranos)]
}
# TENORS
if (dat$voice[l-1]=="T"){
pool <- pool[c(basses, altos, sopranos)]
}
# ALTOS
if (dat$voice[l-1]=="A"){
pool <- pool[c(basses, tenors, sopranos)]
}
# SOPRANOS
if (dat$voice[l-1]=="S"){
pool <- pool[c(basses, tenors, altos)]
}
# don't sit reds next to whites
#================================
reds <- which(pool=="B1_r" | pool=="B2_r" | pool=="T1_r" | pool=="T2_r" | pool=="A1_r" | pool=="A2_r" | pool=="S1_r" | pool=="S2_r")
yellows <- which(pool=="B1_y" | pool=="B2_y" | pool=="T1_y" | pool=="T2_y" | pool=="A1_y" | pool=="A2_y" | pool=="S1_y" | pool=="S2_y")
whites <- which(pool=="B1_w" | pool=="B2_w" | pool=="T1_w" | pool=="T2_w" | pool=="A1_w" | pool=="A2_w" | pool=="S1_w" | pool=="S2_w")
if (dat$colour[l-1]=="w"){
pool <- pool[c(whites, yellows)]
}
if (dat$colour[l-1]=="r"){
pool <- pool[c(yellows, reds)]
}
#========================================================
if (length(pool)==0){
pool <- choir
}
label <- sample(pool, 1)
print(label)
dat$label[l] <- label
dat$voice[l] <- substr(label, 1, 1)
dat$height[l] <- substr(label, 2, 2)
dat$colour[l] <- substr(label, 4, 4)
indx <- which(choir==label)[1]
choir <- choir[-indx]
}
}
#===========================================================
jumbled <- matrix(dat$label, nrow=n_rows, byrow=T)
89/200
200/5
5*13
5*35
5*45
5*38
5*48
5*23
5*32
5*62
5*23
5*25
5*29
5*56
278-5
28-5
5*40
5*60
27-5
23-5
23-5-9
27-9-9
23-9-9
5+9
21-14
21-7-9
5+9
22-9-5
12*5
26.25/5
5.25*30
1-0.967225
1-0.962076
1-0.962443
#===============================================================================
library(lattice)
library(jtools)
library(ggplot2)
setwd("C:/Users/vanes/OneDrive/Documents/GitHub/TuberousSclerosis/Data")
dat <- read.csv("TS2000_dwi_psych.csv", header=T)
dat$id <- factor(dat$id)
dat$group <- factor(dat$group)
dat$sex <- factor(dat$sex)
aggregate(id ~ group, dat, length)
summary(lm(WASI_FSIQ ~ group + age + sex, dat))
summary(lm(SRS2_SC ~ group + age + sex, dat))
summary(lm(SRS2_RRB ~ group + age + sex, dat))
summary(lm(Conners_DSM4_Inattention ~ group + age + sex, dat))
summary(lm(Conners_DSM4_HypImp ~ group + age + sex, dat)) # no difference
# FDC clusters
#==============
# R SLF-I
# png( "Effect1.jpeg",  width = 6, height = 6, units = 'in', res = 300)
ggplot(dat, aes(y=FDC_cluster1_fdc, x=group)) +
geom_boxplot() +
geom_jitter(color="black", size=2, alpha=0.7) +
xlab("Group") + ylab("Mean FDC") +
theme(axis.text=element_text(size=30),
axis.title=element_text(size=30),
plot.title = element_text(size = 30, face = "bold")) +
ggtitle("Right SLF-I")
# dev.off()
summary(lm(FDC_cluster1_fdc ~ group + age + sex, dat))
# dev.off()
summary(lm(FDC_cluster1_fd ~ group + age + sex, dat))
# L ILF
ggplot(dat, aes(y=FDC_cluster3_fdc, x=group)) +
geom_boxplot() +
geom_jitter(color="black", size=2, alpha=0.7) +
xlab("Group") + ylab("Mean FDC") +
theme(axis.text=element_text(size=30),
axis.title=element_text(size=30),
plot.title = element_text(size = 30, face = "bold")) +
ggtitle("Left ILF")
summary(lm(FDC_cluster3_fdc ~ group + age + sex + TIV, dat))
summary(lm(FDC_cluster3_fd ~ group + age + sex, dat))
# R ILF
ggplot(dat, aes(y=FDC_cluster2_fdc, x=group)) +
geom_boxplot() +
geom_jitter(color="black", size=2, alpha=0.7) +
xlab("Group") + ylab("Mean FDC") +
theme(axis.text=element_text(size=30),
axis.title=element_text(size=30),
plot.title = element_text(size = 30, face = "bold")) +
ggtitle("Right ILF")
summary(lm(FDC_cluster2_fdc ~ group + age + sex + TIV, dat))
summary(lm(FDC_cluster2_fd ~ group + age + sex, dat))
dat$FDC_cluster1_fdc
setwd("C:/Users/vanes/OneDrive/Documents/GitHub/TuberousSclerosis/Data")
dat <- read.csv("TS2000_dwi_psych.csv", header=T)
dat$id <- factor(dat$id)
dat$group <- factor(dat$group)
dat$sex <- factor(dat$sex)
aggregate(id ~ group, dat, length)
summary(lm(WASI_FSIQ ~ group + age + sex, dat))
summary(lm(SRS2_SC ~ group + age + sex, dat))
summary(lm(SRS2_RRB ~ group + age + sex, dat))
summary(lm(Conners_DSM4_Inattention ~ group + age + sex, dat))
summary(lm(Conners_DSM4_HypImp ~ group + age + sex, dat)) # no difference
setwd("C:/Users/vanes/Dropbox/KCL_BMEIS/Tuberous Sclerosis/Analysis")
dat <- read.csv("TS2000_Phase_3_data.csv", header=T)
dat$id <- factor(dat$id)
dat$group <- factor(dat$group)
dat$use_dwi <- factor(dat$use_dwi)
dat$sex <- factor(dat$sex)
setwd("C:/Users/vanes/Dropbox/KCL_BMEIS/Tuberous Sclerosis/Analysis/revision/")
fixels <- read.csv("sig_cluster_means_new_tiv_motion.csv", header=T,fileEncoding="UTF-8-BOM")
fixels$id <- factor(fixels$id)
dat <- merge(dat, fixels, by="id")
dat$FDC_cluster1_fdc
dat$FDC_R_ILF_old
dat$FDC_R_ILF
View(dat)
dat$FDC_R_SLF_old
dat$FDC_R_SLF
#===============================================================================
library(lattice)
library(jtools)
library(ggplot2)
setwd("C:/Users/vanes/OneDrive/Documents/GitHub/TuberousSclerosis/Data")
dat <- read.csv("TS2000_dwi_psych.csv", header=T)
dat$id <- factor(dat$id)
dat$group <- factor(dat$group)
dat$sex <- factor(dat$sex)
aggregate(id ~ group, dat, length)
summary(lm(WASI_FSIQ ~ group + age + sex, dat))
summary(lm(SRS2_SC ~ group + age + sex, dat))
summary(lm(SRS2_RRB ~ group + age + sex, dat))
summary(lm(Conners_DSM4_Inattention ~ group + age + sex, dat))
summary(lm(Conners_DSM4_HypImp ~ group + age + sex, dat)) # no difference
# FDC clusters
#==============
# R SLF-I
# png( "Effect1.jpeg",  width = 6, height = 6, units = 'in', res = 300)
ggplot(dat, aes(y=FDC_cluster1_fdc, x=group)) +
geom_boxplot() +
geom_jitter(color="black", size=2, alpha=0.7) +
xlab("Group") + ylab("Mean FDC") +
theme(axis.text=element_text(size=30),
axis.title=element_text(size=30),
plot.title = element_text(size = 30, face = "bold")) +
ggtitle("Right SLF-I")
# dev.off()
summary(lm(FDC_cluster1_fdc ~ group + age + sex + TIV, dat))
summary(lm(FDC_cluster1_fdc ~ group + age + sex + motion, dat))
summary(lm(FDC_cluster3_fdc ~ group + age + sex + TIV, dat))
summary(lm(FDC_cluster3_fdc ~ group + age + sex, dat))
summary(lm(FDC_cluster3_fd ~ group + age + sex, dat))
summary(lm(FDC_cluster2_fd ~ group + age + sex, dat))
t.test(dat$FDC_cluster2_fd, dat$group)
t.test(FDC_cluster3_fd ~ group, dat)
summary(lm(FDC_cluster2_fdc ~ group + age + sex + TIV, dat))
summary(lm(FDC_cluster2_fd ~ group + age + sex, dat))
summary(lm(FDC_cluster1_fc ~ group + age + sex, dat))
summary(lm(FDC_cluster3_fc ~ group + age + sex, dat))
summary(lm(FDC_cluster2_fc ~ group + age + sex, dat))
1-0.960668
1-0.963901
# FDC clusters
#==============
# R SLF-I
# png( "Effect1.jpeg",  width = 6, height = 6, units = 'in', res = 300)
ggplot(dat, aes(y=FDC_cluster1_fdc, x=group)) +
geom_boxplot() +
geom_jitter(color="black", size=2, alpha=0.7) +
xlab("Group") + ylab("Mean FDC") +
theme(axis.text=element_text(size=30),
axis.title=element_text(size=30),
plot.title = element_text(size = 30, face = "bold")) +
ggtitle("Right SLF-I")
aggregate(FDC_cluster1_fdc ~ group, dat, mea)
aggregate(FDC_cluster1_fdc ~ group, dat, mean)
aggregate(FDC_cluster1_fdc ~ group, dat, sd)
aggregate(FDC_cluster1_fdc ~ group, dat, length)
aggregate(FDC_cluster2_fdc ~ group, dat, mean)
aggregate(FDC_cluster2_fdc ~ group, dat, sd)
aggregate(FDC_cluster2_fdc ~ group, dat, mean)
aggregate(FDC_cluster3_fdc ~ group, dat, mean)
aggregate(FDC_cluster3_fdc ~ group, dat, sd)
aggregate(FD_cluster1 ~ group, dat, mean)
aggregate(FD_cluster1 ~ group, dat, sd)
aggregate(FC_cluster1 ~ group, dat, mean)
aggregate(FC_cluster1 ~ group, dat, sd)
